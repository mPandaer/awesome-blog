# MySQL实战 45讲
## 第10讲 MySQL为什么有时候会选错索引？
统计数据 + 扫描行数 + 一些限制条件 会影响MySQL优化器的判断

## 第11讲 怎么给字符串字段加索引
加索引的前提：数据具有区分度，不然提升的效率不高
1. 全字段索引
2. 前缀索引
3. 倒序索引（前缀没有区分度）
4. 额外增加某个字段Hash字段索引 （这个字段长度太大，而且区分度还不高）

倒序索引以及Hash字段索引不支持范围查询。索引是需要迭代的，根据业务量优化过来的。

## 第12讲 MySQL为什么会时不时抖一下
刷脏页，比如内存不足淘汰脏页的时候会刷盘，比如redo log满了之后会刷盘
## 第13讲 为什么表数据删除一半，表文件大小不变
- delete的删除过程是标记删除，后期会复用表空间
- 我们可以通过重建表来释放表空间，重建表的流程是一个重点（Online DDL）
- 在MySQL8.0中，重建表的，数据迁移过程中允许DML操作即增删改
## 第14讲 count(\*) 为什么这么慢？
## 第15讲 日志和索引的答疑
- redo log并没有参与到最终的落盘中，落盘还是基于内存写的
## 第16讲 order by是如何工作的？
- order by field 如何这个字段上没有索引就会排序，如果有就不需要排序
- 如果sort_buffer足够排序，就直接在内存中排序，如果不够，就需要借助临时文件进行归并排序
- 排序有两种方式，一种是全字段排序，一种是rowid排序。选择的标准就是当行的数据长度是否超过`max_length_for_sort_data` 规定的长度，超过了就是用rowid排序，没有超过就是用全字段排序
## 第17讲 如何正确的显示随机消息
- 先通过原理分析算出扫描行数，然后再通过查看慢查询日志，来验证自己的结论，也就是通过原理分析出结果，再通过实践验证结果
- 规范的用法就是：尽量将业务逻辑写在业务代码中，让数据库只做“读写数据”的事情
- 排序算法：归并排序（基于临时文件），堆排序（基于内存）
    - 归并排序比较通用
    - 堆排序，一般是返回的数据量比较上，比如limit 3
- 随机选数据，建议的做法，先保证数据的主键ID连续，然后随机一个ID，然后就可以提取出来了。这样最高效，最简单
