# 笔记之代码生成器平台
## 代码生成器平台 第一期
第一期主要是项目的介绍，告诉我们要做什么样的项目，包括需求分析，技术选型
[相关链接](https://www.codefather.cn/course/1790980795074654209/section/1790994867614691330?contentType=text&tabKey=videoList&type=) 终极目标：在线制作代码生成器，分为三个阶段
1. 阶段一：学习如何制作脚手架 （代码生成器）**1~3期**
2. 阶段二：将制作脚手架的流程用代码实现出来 （脚手架制作工具）
3. 阶段三：将脚手架制作工具上云，提供Web界面进行操作
## 代码生成器平台 第二期
第二期的核心任务就是**完成代码生成器的核心流程**，我认为的核心流程如下：
1. 需要一个原始的工程文件
2. 分析原始工程文件哪些是固定不变的，哪些是可以扩展的，可以扩展的利用动态模版技术，固定不变的直接复制粘贴
3. 将原始的工程文件变成一个代码生成器源包，即动态模版文件 + 静态文件 
4. 代码生成器源包 + 相关的参数 == 原始工程文件的变种。比如输出格式变化，代码文件的注释变化等等
## 代码生成器平台 第三期
第三期的核心任务就是**提供CLI**，为用户与程序提供一个交互的手段。保证用户可以输入一些参数生成定制化的代码
### 课堂记录
- 对于自己没有使用过的技术，必须进行充分的调研，需要花费大量的时间
- 对于新技术，看官方文档，如果官方文档看不懂才去看视频教程，看文本教程，问GPT
- 快速入门 ==> 实用（核心）功能
	- 核心功能从快速入门的案例中提取
- 验证 交互式 + 必需参数
- 学习一下命令设计模式 实践一下
- 明确需求很重要 需求，需求，需求！
## 代码生成器平台 第四期
第四期的核心任务：拆分脚手架制作工具的需求，分为三个阶段，并完成第一个阶段的任务。
1. 在假设源包制作好的基础上，实现脚手架制作工具的主题流程
2. 优化代码，增加元信息配置文件的能力
3. 优化功能，源包如何使用脚手架制作工具生成
### 课堂记录
- 脚手架制作工具做的事情：  元信息配置文件 +制作工具（源包的配置，模型对象的配置） ==>   源包的生成 + 模型对象 + 脚手架核心逻辑的生成
- 面对需求束手无策时，需要拆解需求 分阶段进行需求分析
- 先跑通核心流程，在优化和增加功能
- 当你不知道怎么做的时候，百度，问AI，借鉴别人的，参考别人 + 自己的需求
- **验证**：写文件的时候，如果文件不存在就不会自动创建吗？
- 插件转换：JSON对象转换为Java类 GsonFormatPlus RoboPOJOGenerator
- JSON 数据转换为Java对象是有性能损耗的
- 疑问：反射能动态生成代码？
- IDEA有个好用的小功能，FindUsage
### 我的收获
1. 需求分析，需求拆解很重要！
2. 人无完人，总会遇到自己没有接触过的东西，不会东西，这个时候需要有一套方法论指导自己学习新东西，或者解决没有接触过的问题。核心就是：模仿借鉴 + 结合实际
## 代码生成器平台 第五期
1. 可移植性优化 sourceRootPath 换个环境看看是否可以正常执行
2. 功能优化 增加说明文档（脚手架）
3. 健壮性优化 特殊条件下，能够稳定运行 元信息配置文件的校验
4. 可扩展性优化 让别人认为好修改代码，方便增加功能。尽量不要出现魔法值 模版方法模式

- 空间优化 产物包
- 扩展点：.git 代码托管
- 异常最好做成枚举的 可以有一个兜底值
- 量化代码复杂度：圈复杂度 < 10 插件：MetricsReloaded
- **验证**：static方法不能被重写，为什么？
    - 重写的目的是利用多态，而多态需要基于对象而非类，而静态方法属于类而非对象
## 代码生成器平台 1~5期编码实现
我觉得可以分为三个大的步骤：
1. 项目的初始化 30min
2. 手动制作代码生成器 1h
    - 准备一个初始工程文件
    - 定义一些概念
1. 利用工具制作代码生成器（假定源包已存在）1h
### 项目初始化
1. 导入依赖
    - 工具包 Hutool 实用的工具类
    - 动态代码模板 freemarker  负责代码生成的核心逻辑
    - 命令行框架 picocli 负责提供CLI式的访问方式
### 手动制作代码生成器（ACM）
1. 先确认哪些文件需要动态生成，哪些文件可以直接复制
2. 定义数据模型（动态文件需要的）即我们可以定制化的部分
3. 制作源包（静态文件 + 动态文件）
4. 测试一下FreeMarker是否可以正常工作 简单测试 + 自带的动态文件测试
5. 利用源包 + 数据模型 生成定制化的工程代码
6. 为这个逻辑提供命令行的访问方式

- **问题1**：文件路径问题 反斜杠与斜杠 以及 路径开头是否有/ 这些问题
- **问题2**：打成Jar包后，无法直接遍历Jar包中的文件了
- **问题3**：不能以文件的形式，访问Jar包中内容
## 代码生成器 第六期 核心篇
### 课堂记录
- 具体的例子驱动开发
- 需求驱动，任务驱动
- 聚合搜索项目中存在ES的教程
- 从具体的例子中分析通用的能力，有点测试驱动开发哪个味道，这样写出来的代码可以复用，可以扩展
- 学习：了解一下分布式Session在Java中的实现
- 元信息配置文件是描述代码生成器的各个方面，其中就包括了数据模型长什么样
- 抽象能力的培养：不断的做，不断写设计文档，不断的学习其他的项目
- 基于具体的例子开发，如果没有任何想法的话，一定要基于具体而非抽象
- 越使用，越亲近，越熟悉
- **核心**：从个例中梳理出通用需求的能力

### 通用功能分析
1. 利用制作工具自动帮我们将原始文件"挖坑"变成动态文件
2. 利用一个参数去生成多个文件，或者不生成多个文件 在文件配置中增加一个新的分组类型
3. 用一个参数控制某个文件是否生成 在文件配置中增加一个属性condition
4. 用一个参数管理是否开启某个配置，如果开启，就需要另外的一组配置，类似嵌套对象
5. 针对分析好的需求进行排期，进行优先级排序，由简单到复杂
## 代码生成器 第七期 核心篇 上
> 模板制作工具
- 元信息配置文件也可以基于 原始工程文件 + 模板制作工具直接生成
- 数据模型对象与动态文件强依赖
- 分析 设计 编码（核心流程再功能增强）
- 模版制作工具的作用只能提高效率，不能覆盖全部的定制化需求
- **注意**！开始实现需求的时候，实现主体的流程，跑通流程很重要！
- 需要弄明白路径问题，这类由于操作系统不同，路径格式不一致的问题。
- 工作空间的隔离
- 自下而上开始写代码，逻辑很乱，或者叫没有设计写代码，逻辑很乱，我们可以参考TDD的思路，红绿循环，基于个例写的代码，写完之后一定要进行重构，然后再接着完成第二个例子。这样做会好一些。
- 路径中还存在一个反斜杠，以及多个反斜杠的问题
- **验证**：JSON的反斜杠是否也有转义的问题
- Java中的String的replace与replaceAll方法名写的不好，replace也是可以替换全部的
- 这一个视频逻辑有点乱，需要看看文字教程，需要慢慢啃一下
- 视频中违反的**单一责任的原则**，所以越写越乱，越不容易理解。
### 自己的理解
这一期的核心在于挖坑，由用户指定一些文件内容中存在的关键字，我们利用字符串替换的策略将关键字替换为动态模板文件的占位标识，并顺带的生成元信息配置文件，或者叫持久化元信息配置文件。
## 代码生成器 第七期 核心篇 下
- 为什么要做文件过滤？
- 在元信息配置文件中增加 生成模板文件的配置参数
- 这里的文件过滤功能可以稍微设计一下，比如定义一个过滤接口，有一个filter方法，创建一个类，实现这个接口，这个类接受两个属性，一个是过滤范围（文件名，文件内容），一个是过滤策略（前缀匹配，后缀匹配，正则表达式匹配，还是简单的字符串相等），过滤范围FilterRage类，过滤策略FilterStrategy，然后过滤范围有一个方法getContent(File) 过滤策略有一个match(Content)方法，在过滤器中的filter方法，先调用过滤范围的getContent(File)方法获取到过滤的内容，然后利用过滤策略校验这个过滤内容是否满足条件。
- 讲解的过程有点乱。
- 在最开始没有很好的设计，或者说设计不够明确，没有根据需求划分出一些简单的组件，职责不明确，脑容量有限，整段逻辑很容易迷糊
- 这个文件过滤需求：根据某些条件，判断在原始工程中哪些文件需要做成动态模板，哪些不需要。
- 这段视频之所以讲着绕一绕的，就是需求没有说明白，不知道目的是什么？然后所有逻辑全部耦合在一起了，每次增加功能的时候，总是需要梳理一遍逻辑，逻辑过多容易遗忘。
- 这段视频讲的真的不是很好，有很大的问题，第一难以跟上，第二需求简单说明就开始动代码，很难理解，可能文字教程会好一起，对我而言。我反正没有跟上。尤其是最后一节视频，我完全不知道在干嘛了。
### 我的感受
1. 讲的比较混乱，可能与我没有完成之前的代码有关，但是关系应该不大
2. 讲的混乱的原因就在于，需求说了，但是没有说明需求该如何做？没有分个具体的步骤
3. 把所有的逻辑都写在一堆，没有很好的抽象出一些逻辑，导致后续扩展的时候，容易脑容量不足。
## 代码生成器平台 1~5期编码实现 
- BUG：源包在jar中，无法以文件的形式进行遍历，如果要实现类似的功能，会比较复杂，可能需要大改整个生成的逻辑，后期来做，这里还是还是不要将源包文件放入资源文件夹中！
- 验证：在构造器中抛出的运行时异常似乎没有什么错误信息报警
- 额外的功能：集成日志组件
```java
public DynamicGenerator(String templateRootDir) {  
    try {  
        this.configuration = initTemplateEngineConfig(templateRootDir);  
    } catch (IOException e) {  
        throw new RuntimeException(e);  
    }  
}
```
- 待梳理：file.getPath() --> D:/code/simple-pd-generator/simple-acm-generator/.sourcepkg/acm-template/src/main/java/com/pandaer/InputTemplate.java.ftl
    - 核心问题就是这个分隔符，什么时候是\ 什么时候是/
- ~~BUG:~~ 利用Jar执行生成的代码文件存在中文乱码 解决方式：修改JVM参数，以及终端的参数
### 代码生成器工厂（代码生成器制作工具） 编码实现
存在两个模块：
1. 源包制作模块
2. 代码生成模块
#### 第一阶段 跑通核心流程（假设源包制作模块完成）
- 完成代码生成模块
定义元信息配置文件作用：描述代码生成器长什么样的
元信息（极简版）（JSON文件作为载体）：
1. 基本信息 （代码生成器的名字，版本，作者，创建时间）
2. 源包相关的描述（即原始工程文件中，哪些是动态文件，哪些是静态文件）
3. 数据模型的描述
```json
{  
  "basicInfo": {  
    "name": "acm输入模版代码生成器",  
    "description": "一个简单的ACM输入模版生成器",  
    "version": "1.0.0",  
    "createTime": "2024-12-8"  
  },  
  "sourcePkg": {  
    "originProjectPath": "原始工程文件的目录",  
    "files": [  
      {  
        "originFileRelativePath": "原始文件路径（原始工程文件中的文件路径）",  
        "type": "static"  
      },  
      {  
        "originFileRelativePath": "原始文件路径（原始工程文件中的文件路径）",  
        "type": "dynamic",  
        "args": {  
          "replacement": "原始文件中需要替换的文本内容",  
          "key": "模型配置中的字段名"  
        }  
      }  
    ]  
  },  
  "dataModel": {  
    "fields": [  
      {  
        "name": "字段名",  
        "type": "字段类型Java中的类型，最好是全限定类型",  
        "description": "字段信息描述",  
        "abbr": "参数缩写",  
        "defaultValue": "默认值"  
      }  
    ]  
  }  
}
```
- files字段中的配置存在默认行为，没有配置的认为是静态文件
一个例子：
```json
{  
  "basicInfo": {  
    "name": "ACM输入模版代码生成器",  
    "description": "一个简单的ACM输入模版生成器",  
    "version": "1.0.0",  
    "createTime": "2024-12-8"  
  },  
  "sourcePkg": {  
    "originProjectPath": "D:/code/simple-pd-generator/origin-project-demos/acm-template",  
    "files": [  
      {  
        "originFileRelativePath": ".gitignore",  
        "type": "static"  
      },  
      {  
        "originFileRelativePath": "README.md",  
        "type": "static"  
      },  
      {  
        "originFileRelativePath": "pom.xml",  
        "type": "dynamic"  
      },  
      {  
        "originFileRelativePath": "src/main/java/com/pandaer/InputTemplate.java",  
        "type": "dynamic"  
      }  
    ]  
  },  
  "dataModel": {  
    "fields": [  
      {  
        "name": "author",  
        "type": "String",  
        "description": "作者",  
        "abbr": "a",  
        "defaultValue": "匿名作者"  
      },  
      {  
        "name": "loop",  
        "type": "boolean",  
        "description": "控制ACM输入模板中的循环部分的生成",  
        "abbr": "l",  
        "defaultValue": "true"  
      },  
      {  
        "name": "displayText",  
        "type": "String",  
        "description": "控制输出的文本信息",  
        "defaultValue": "输出："  
      }  
    ]  
  }  
}
```
- 配置文件，配置类创建完成
- 假设源包制作工具是已经完成的条件下，完成代码生成模块
- **验证**：模型属性的生成，与视频中的存在不一致的问题。
### 小结
- 实现了一个极简版本的制作工具，即假设源包制作模块已完成。
- 梳理的图如下：
![](images/代码生成器共享平台.png)
## 代码生成器共享平台实现 『功能优化』
- 完善流程，即支持自动打包（如果存在Maven）🍃
- 可移植性优化 相对路径改为绝对路径 🍃
- 功能优化：生成比较完整的README.md文档 🍃
- 功能增强：脚本文件支持兼容Windows平台，Linux平台 🍃
- 生成精简版代码生成器 即 jar包，源包，脚本文件。🍃
- 扩展点：生成的代码生成器可以交给Git托管（待实现）
- 健壮性优化：参数校验，异常处理，故障恢复 我们这里直接针对元信息配置文件进行参数校验以及兜底 🍃
- 圈复杂度优化：下载插件，测试圈复杂度 🍃
- 可扩展性优化：我们关注功能可扩展性 🍃
    - 尽量少使用硬编码，少使用魔法值
    - 利用模板方法模式固定整个代码生成器工厂的生产步骤
### 问题
- 源包，脚本文件的生成路径上必须拼接出一个当前工作空间 优化点，如果是相对路径就拼上一个工作目录 通过元信息参数校验的时候，拼接了一个当前工作空间（已解决）
