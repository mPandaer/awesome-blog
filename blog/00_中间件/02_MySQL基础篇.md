# MySQL 核心基础

MySQL一个后端开发必须会接触的中间件，也是关系型数据库的代表。如果你希望看下去这篇文章，需要你有使用MySQL或者相关关系型数据库的经验，不然这篇文章在你眼中就会索然无味了。

这篇文章不会讲解如何使用MySQL，例如如何安装？如何创建表，如何增删改查数据？如果你期望的是这样的内容，这篇文章也不适合你。

那么这篇文章讲什么呢？在此之前我想说说我学习后端中间件的思路，无论是Redis，还是ES，或者RabbitMQ。学习这种东西，我们可以分为两个维度，一个是使用者的维度，重点在于如何利用它的特点完成我们的功能。基本上都是增删改查。第二个维度就是开发者的角度，我们需要了解它的整体架构，它是如何完成一些核心操作的，就拿MySQL来说，它是如何实现数据的读写的？而这篇文章正是站在一个开发者的角度，介绍MySQL中的核心组件的。

这篇文章我会从MySQL的基础架构讲起，然后聊到MySQL中两个比较重要的日志，redo log,bin log，接着会聊聊MySQL是如何组织数据，然后会聊聊MySQL作为关系型数据库的事务以及锁功能。

## MySQL的基础架构

了解一个组件的全貌，方便我们定位问题，分析问题，也能够让我们在研究其原理的时候，不会陷入细节而白白浪费时间。下面这张图就是MySQL的基础架构图

![MySQL.drawio](./images/MySQL.drawio.png)

总的来说，MySQL是CS架构，Client通过网络将SQL语句交给Server端，Server端处理之后，将数据通过网络返回给Client。我们的重点在Server端，Server端大致分为两层，一个是服务层，一个是存储引擎层。我们通过一个例子将Server端的组件串起来。例子如下

```mysql
select user_id,user_name from user;
```

假设user表只有两个字段，一个是userId,一个是username,其中userId是主键。当客户端发起查询语句的时候，流程是这样的：

1. 建立连接，客户端与连接器建立连接，连接器负责校验用户名和密码，并读取这个用户的权限作为后续的基础
2. 连接建立完毕后，连接器将SQL语句交给分析器进行词法分析以及语法分析生成抽象语法树，换句话说就是在校验SQL语句的语法是否正确，是否存在这个表，表中的字段是否存在。
3. 当分析出这个SQL语句要做的事情之后（要做什么），分析器会将这个抽象语法树交给优化器，优化器根据抽象语法树生成最佳的执行计划，换句话说就是把要**做什么** 转换为 **怎么做**。
4. 分析器将这个执行计划交给执行器，执行器会校验这个用户是否有权限操作这个表，然后打开表并利用存储引擎提供的读写接口检索数据，最后将数据返回给客户端。

相信通过上面的介绍，你对MySQL的总体结构有了一定的了解，也知道了真实操作数据的是存储引擎层中具体的存储引擎，而接下来我们会以主流的InnoDB为例介绍后续的相关内容。

查询语句的执行流程我们清楚了，那更新语句呢？

## MySQL的日志系统

MySQL中有三种重要的日志，一个是binlog,redolog,undolog,而在这一节中，我会和你介绍binlog,redolog,至于undolog会在介绍事务的时候与你详细说说。

不过在谈日志系统之前，你需要知道一个知识，**磁盘的随机读写的IO成本大于磁盘的顺序读写IO成本，而写日志利用的是磁盘的顺序读写。**

首先我们先来看看这两种日志处于的位置，binlog位于服务层，而redolog是InnoDB存储引擎独有的。之所以是这样是由于这两种日志的作用不同。binlog也被我们称为归档日志，主要的用途是用作数据备份，主从同步。而redolog的作用是InnoDB提高更新操作性能的一个手段。我们知道磁盘的读写是同步操作，会导致阻塞。执行器在修改数据的时候，会调用存储引擎提供的写接口，如果使用的InnoDB的话，会将这个写操作记录到redolog中，然后就会返回OK，执行器就会认为修改数据成功。InnoDB利用redolog将磁盘的随机写转换为磁盘的顺序写，提高了写操作的性能。这就是redolog的一个作用。当然redolog可不止这一个作用，redolog也常常被用于MySQL的崩溃恢复，保证数据的一致性。讲完了这两种日志的作用，我们来看看它们的相同点以及不同点。

最大的相同点就是binlog与redolog都只记录更新的操作。最大的不同点就在于binlog可以一直写，而redolog是一个环形日志文件，大小固定，如果写满了会覆盖之前的更新记录。其次就是写的东西不同，binlog记录的是SQL操作，而redolog记录的更加细致一些，记录的是数据页的修改动作。多个数据页的操作才对应一个SQL操作。所以通常binlog的写时机在事务提交的时候，而redolog在事务开始的时候都会有写操作了。为了满足数据的一致性，以及binlog与redolog的逻辑正确，就出现了两阶段提交。即当事务提交的时候，先往redolog写一条日志，标志这个事务的状态为prepared，然后开始写binlog，等binlog写完之后再往redolog中写一条日志标志这个事务的状态为commit。到此这个事务才算真正的提交了。

我们通过这个例子将这两个日志串起来，例子如下：

```mysql
update `user` set `user_name` = 'pandaer' where `user_id` = 1001
```

大部分的逻辑和查询语句差不多，先建立连接，将SQL语句交给分析器，执行器执行优化器生成的执行计划。不同点就在执行器调用存储引擎提供的写接口上。当执行器找到user表中user_id等于1001的数据之后，会先在redolog中记录要在哪个数据页的哪个位置修改什么数据，然后事务提交，就会进入两阶段提交的过程，这个时候binlog就会写入这个SQL操作，最后事务结束，更新语句结束。至于数据文件的更新会由MySQL的后台线程进行刷新。

## MySQL的索引

未完待续…

## MySQL的锁

未完待续…

## MySQL的事务

未完待续…





















































